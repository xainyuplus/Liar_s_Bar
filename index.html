<!DOCTYPE html>
<!-- 这个页面是主页+游戏大厅+创建房间 -->
<!-- 如果后面有需要，会再加登录等其他页面 -->
<html lang="en">

<head>
   <meta charset="UTF-8">
   <meta name="viewport" content="width=device-width, initial-scale=1.0">
   <title>Document</title>

   <link rel="stylesheet" href="./CSS/lobby.css">
   <link rel="stylesheet" href="./CSS/game.css">
   <link rel="stylesheet" href="./CSS/main.css">
   <!-- 这几个CSS其实是有冲突的，要想办法消除一下，现在算了-->
   <style>
      .player-self {
         position: fixed;
         /* 使用固定定位 */
         left: 20px;
         /* 距离屏幕左侧 20px */
         bottom: 20px;
         /* 距离屏幕底部 20px */
         display: flex;
         /* 使用 flex 布局 */
         flex-direction: column;
         /* 垂直排列子元素 */
         align-items: center;
         /* 子元素水平居中 */
         background-color: rgba(240, 240, 240, 0.6);
         ;
         /* 设置半透明背景 */
         padding: 15px;
         /* 添加内边距 */
         border-radius: 10px;
         /* 圆角边框 */
         box-shadow: 0 0 10px rgba(0, 0, 0, 0.2);
         /* 添加阴影 */
         z-index: 10;
         /* 设置 z-index，确保显示在其他元素之上 */
      }

      .player-self .player-character {
         display: flex;
         flex-direction: column;
         align-items: center;
         margin-bottom: 10px;
         /* 与下方信息区域保持间距 */
      }

      .player-self .player-info {
         text-align: center;
         margin-bottom: 10px;
         /* 与下方子弹计数器保持间距 */
      }

      .player-self .bullet-counter {
         display: flex;
         align-items: center;
      }

      .player-self .bullet-display {
         display: flex;
         margin-left: 5px;
         /* 与枪图标保持间距 */
      }

      .player-self .bullet {
         display: flex;
         margin-left: 5px;
         /* 与枪图标保持间距 */

      }

      .player-self .bullet.used {
         background-color: #ccc;
         /* 已使用子弹颜色 */
      }
   </style>
</head>
<!-- 加载所有JavaScript模块 -->
<script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>
<!--socket模块-->
<script src="js/socket-client.js"></script>

<!-- 数据模块 -->

<!-- UI组件 -->
<script src="js/ui/screens/ScreenManner.js"></script>
<!-- 工具模块 -->
<script src="js/utils/animationUtils.js"></script>
<!-- 主控制器 -->
<script src="js/main.js"></script>
<!-- 引入 SweetAlert2 库 -->
<script src="https://cdn.jsdelivr.net/npm/sweetalert2@11"></script>

<body>

   <div id="lobby-screen" style="z-index: 1;" class="screen hidden">
      <div class="bg-decoration"></div>

      <div class="container">
         <!-- 顶部栏 -->
         <header class="header">
            <div class="user-info">
               <div class="user-avatar">😁</div>
               <div class="user-details">
                  <h3>玩家</h3>
                  <p>等级 15 | 金币 2,580</p>
               </div>
            </div>
            <button class="settings-btn" onclick="showSettings()">⚙️</button>
         </header>

         <!-- 主要内容区域 -->
         <main class="main-content">
            <!-- 角色展示区 -->
            <section class="character-display">
               <div class="character-container">
                  <div class="character-avatar">
                     <div class="character-accessory">🎩</div>
                     <div class="character-head">😁</div>
                     <div class="character-clothes">👗</div>
                     <div class="character-item-left">💰</div>
                     <div class="character-item-right">🗝️</div>
                  </div>
                  <h2 class="character-name">神秘旅者</h2>
                  <p class="character-title">酒馆常客 · 真相探索者</p>
                  <button class="customize-btn" onclick="customizeCharacter()">
                     🎭 换装打扮
                  </button>
               </div>
            </section>

            <!-- 功能按钮区 -->
            <section class="function-area">
               <div class="main-actions">
                  <button class="primary-btn" id="createBtn" onclick="createRoom()">
                     🏠 创建房间
                  </button>

                  <div class="join-room-container">
                     <input type="text" class="room-input" placeholder="输入房间号" id="roomId">
                     <button class="secondary-btn" onclick="joinRoom()">🚪 加入</button>
                  </div>

                  <button class="secondary-btn" onclick="quickMatch()">
                     🎲 快速匹配
                  </button>
               </div>

               <!-- 辅助功能区 -->
               <div class="secondary-features">
                  <div class="feature-card" onclick="openShop()">
                     <span class="feature-icon">🛍️</span>
                     <div class="feature-title">商店</div>
                     <div class="feature-desc">装扮道具</div>
                  </div>

                  <div class="feature-card" onclick="openActivity()">
                     <span class="feature-icon">🎉</span>
                     <div class="feature-title">活动</div>
                     <div class="feature-desc">每日任务</div>
                  </div>

                  <div class="feature-card" onclick="openRanking()">
                     <span class="feature-icon">🏆</span>
                     <div class="feature-title">排行榜</div>
                     <div class="feature-desc">高手如云</div>
                  </div>
               </div>
            </section>
         </main>
      </div>

      <!-- 好友侧栏 -->
      <div class="friends-sidebar" id="friendsSidebar">
         <button class="friends-toggle" onclick="toggleFriends()">👥</button>
         <div class="friends-header">好友列表</div>
         <div class="friends-list">
            <div class="friend-item">
               <div class="friend-avatar">😊🎩</div>
               <div class="friend-info">
                  <h4>智慧法师</h4>
                  <p>正在游戏中</p>
               </div>
               <div class="online-status"></div>
            </div>

            <div class="friend-item">
               <div class="friend-avatar">🤔💼</div>
               <div class="friend-info">
                  <h4>商人老板</h4>
                  <p>5分钟前在线</p>
               </div>
               <div class="online-status offline-status"></div>
            </div>

            <div class="friend-item">
               <div class="friend-avatar">😏🗝️</div>
               <div class="friend-info">
                  <h4>神秘盗贼</h4>
                  <p>正在大厅</p>
               </div>
               <div class="online-status"></div>
            </div>

            <div class="friend-item">
               <div class="friend-avatar">😎🎭</div>
               <div class="friend-info">
                  <h4>表演艺术家</h4>
                  <p>离线</p>
               </div>
               <div class="online-status offline-status"></div>
            </div>
         </div>
      </div>
   </div>

   <div id="room-wating" style="z-index: 2;">
      <div id="playersDiv" style="display: none; flex-direction: column; align-items: center; position: relative;">
         <button id="closeButton"
            style="position: absolute; top: 10px; right: 10px; font-size: 24px; border: none; cursor: pointer;">×</button><span
            id="roomIDspan"></span>
         <div id="avatarsContainer" style="display: flex; justify-content: space-around; width: 100%;">
            <img src="./assets/images/avatars/avatar0.png" style="width: 60px; height: 60px; margin: 10px;">
            <img src="./assets/images/avatars/avatar0.png" style="width: 60px; height: 60px; margin: 10px;">
            <img src="./assets/images/avatars/avatar0.png" style="width: 60px; height: 60px; margin: 10px;">
            <img src="./assets/images/avatars/avatar0.png" style="width: 60px; height: 60px; margin: 10px;">
         </div>
         <div id="namesContainer" style="display: flex; justify-content: space-around; width: 100%;"><span
               style="margin: 10px;">玩家1</span><span style="margin: 10px;">玩家2</span><span
               style="margin: 10px;">玩家3</span><span style="margin: 10px;">玩家4</span></div><button
            id="startButton">开始游戏</button>
      </div>
   </div>

   <div id="loading-overlay" style="z-index: 3;">
      <div class="spinner"></div>
      <div class="loading-text" id="loading-text">加载中</div>
      <div class="loading-dots"></div>
   </div>
   <div id="game-screen" style=" z-index: 1;" class="screen hidden">
      <div class="game-container">
         <!-- 玩家自身区域 -->
         <div class="player-self" id="playerSelf">
            <!-- 玩家角色 -->
            <div class="player-character">
               <!-- 玩家角色配饰 -->
               <div class="character-accessory">🎩</div>
               <!-- 玩家角色头部 -->
               <div class="character-head">😁</div>
               <!-- 玩家角色衣服 -->
               <div class="character-clothes">👗</div>
               <!-- 玩家角色左侧物品 -->
               <div class="character-item-left">💰</div>
               <!-- 玩家角色右侧物品 -->
               <div class="character-item-right">🗝️</div>
            </div>
            <!-- 玩家信息 -->
            <div class="player-info">
               <!-- 玩家名称 -->
               <div class="player-name">玩家</div>
               <!-- 玩家牌数量 -->
               <div class="player-cards">5 张牌</div>
            </div>
            <!-- 玩家子弹计数器 -->
            <div class="bullet-counter">
               <!-- 枪图标 -->
               <span>🔫</span>
               <!-- 子弹显示区域 -->
               <div class="bullet-display">
                  <!-- 6 颗未使用的子弹 -->
                  <div class="bullet"></div>
                  <div class="bullet"></div>
                  <div class="bullet"></div>
                  <div class="bullet"></div>
                  <div class="bullet"></div>
                  <div class="bullet"></div>
               </div>
            </div>
         </div>
         <!-- 倒计时器 -->
         <div class="timer-area">
            <!-- 倒计时显示区域，初始值为 30 -->
            <div class="timer" id="timer">30</div>
         </div>

         <!-- 目标牌区域 -->
         <div class="target-area">
            <!-- 目标牌标签 -->
            <div class="target-label">目标牌</div>
            <!-- 目标牌显示区域，初始值为 ♠K -->
            <div class="target-card" id="targetCard"></div>
            <!-- 回合信息，初始为第 1 轮 -->
            <div class="round-info">第 1 轮</div>
         </div>

         <!-- 游戏主区域 -->
         <div class="game-main">
            <!-- 第一个对手 -->
            <div class="opponent" id="opponent2">
               <!-- 对手角色 -->
               <div class="opponent-character">
                  <!-- 对手角色配饰 -->
                  <div class="character-accessory">🎩</div>
                  <!-- 对手角色头部 -->
                  <div class="character-head">😊</div>
                  <!-- 对手角色衣服 -->
                  <div class="character-clothes">👔</div>
                  <!-- 对手角色左侧物品 -->
                  <div class="character-item-left">💰</div>
                  <!-- 对手角色右侧物品 -->
                  <div class="character-item-right">🔍</div>
               </div>
               <!-- 对手信息 -->
               <div class="opponent-info">
                  <!-- 对手名称 -->
                  <div class="opponent-name">智慧法师</div>
                  <!-- 对手牌数量 -->
                  <div class="opponent-cards">5 张牌</div>
               </div>
               <!-- 对手子弹计数器 -->
               <div class="bullet-counter">
                  <!-- 枪图标 -->
                  <span>🔫</span>
                  <!-- 子弹显示区域 -->
                  <div class="bullet-display">
                     <!-- 6 颗未使用的子弹 -->
                     <div class="bullet"></div>
                     <div class="bullet"></div>
                     <div class="bullet"></div>
                     <div class="bullet"></div>
                     <div class="bullet"></div>
                     <div class="bullet"></div>
                  </div>
               </div>
            </div>
            <!-- 第二个对手 -->
            <div class="opponent" id="opponent3">
               <!-- 对手角色 -->
               <div class="opponent-character">
                  <!-- 对手角色配饰 -->
                  <div class="character-accessory">💼</div>
                  <!-- 对手角色头部 -->
                  <div class="character-head">🤔</div>
                  <!-- 对手角色衣服 -->
                  <div class="character-clothes">🦺</div>
                  <!-- 对手角色左侧物品 -->
                  <div class="character-item-left">📊</div>
                  <!-- 对手角色右侧物品 -->
                  <div class="character-item-right">💎</div>
               </div>
               <!-- 对手信息 -->
               <div class="opponent-info">
                  <!-- 对手名称 -->
                  <div class="opponent-name">商人老板</div>
                  <!-- 对手牌数量 -->
                  <div class="opponent-cards">5张牌</div>
               </div>
               <!-- 对手子弹计数器 -->
               <div class="bullet-counter">
                  <!-- 枪图标 -->
                  <span>🔫</span>
                  <!-- 子弹显示区域 -->
                  <div class="bullet-display">
                     <!-- 3 颗未使用的子弹和 3 颗已使用的子弹 -->
                     <div class="bullet"></div>
                     <div class="bullet"></div>
                     <div class="bullet"></div>
                     <div class="bullet "></div>
                     <div class="bullet "></div>
                     <div class="bullet "></div>
                  </div>
               </div>
            </div>
            <!-- 第三个对手，处于激活状态 -->
            <div class="opponent active" id="opponent1">
               <!-- 对手角色 -->
               <div class="opponent-character">
                  <!-- 对手角色配饰 -->
                  <div class="character-accessory">🎭</div>
                  <!-- 对手角色头部 -->
                  <div class="character-head">😏</div>
                  <!-- 对手角色衣服 -->
                  <div class="character-clothes">👘</div>
                  <!-- 对手角色左侧物品 -->
                  <div class="character-item-left">🗝️</div>
                  <!-- 对手角色右侧物品 -->
                  <div class="character-item-right">⚔️</div>
               </div>
               <!-- 对手信息 -->
               <div class="opponent-info">
                  <!-- 对手名称 -->
                  <div class="opponent-name">神秘盗贼</div>
                  <!-- 对手牌数量 -->
                  <div class="opponent-cards">5 张牌</div>
               </div>
               <!-- 对手子弹计数器 -->
               <div class="bullet-counter">
                  <!-- 枪图标 -->
                  <span>🔫</span>
                  <!-- 子弹显示区域 -->
                  <div class="bullet-display">
                     <!-- 6 颗未使用的子弹 -->
                     <div class="bullet"></div>
                     <div class="bullet"></div>
                     <div class="bullet"></div>
                     <div class="bullet"></div>
                     <div class="bullet"></div>
                     <div class="bullet"></div>
                  </div>
               </div>
            </div>

            <!-- 中央牌桌 -->
            <div class="table-area">

               <div class="table-center">
                  <!-- 已出牌区域 -->
                  <div class="played-cards-area" id="playedCards"></div>

                  <!-- 出牌信息 -->
                  <div class="played-info" id="playedInfo">qq</div>
               </div>
            </div>
         </div>
      </div>

      <!-- 手牌区域 -->
      <div class="hand-area">
         <!-- 手牌显示区域 -->
         <div class="hand-cards" id="handCards">

         </div>

         <!-- 行动按钮区域 -->
         <div class="action-area">
            <!-- 质疑按钮，点击触发质疑函数 -->
            <button class="action-btn" id="challengeBtn" onclick="challenge()">
               🔫 质疑
            </button>
            <!-- 选择信息显示区域 -->
            <div class="selection-info" id="selectionInfo">
               请选择 1-3 张牌
            </div>
            <!-- 出牌按钮，初始禁用，点击触发出牌函数 -->
            <button class="action-btn" id="playBtn" onclick="playSelectedCards()">
               🃏 出牌
            </button>
         </div>
      </div>

      <!-- 聊天与表情面板 -->
      <div class="chat-panel" id="chatPanel">
         <div class="chat-header">
            <span>💬 聊天 & 表情</span>
            <button class="chat-toggle" id="chatToggle" onclick="toggleChat()">−</button>
         </div>
         <div class="chat-content" id="chatContent">
            <div class="chat-messages" id="chatMessages">
               <div class="chat-message system">游戏开始！目标牌是 K</div>
               <div class="chat-message player">智慧法师: 😊 大家好运！</div>
               <div class="chat-message player">商人老板: 🤔 让我想想...</div>
            </div>

            <div class="toggle-buttons">
               <button class="toggle" id="toggle-emoji-btn" onclick="toggleEmojiPanel()">
                  😀 显示表情
               </button>
               <button class="toggle" id="toggle-quick-btn" onclick="toggleQuickPanel()">
                  💬 显示短语
               </button>
               <button class="toggle" id="send-btn" onclick="sendMessage()">发送</button>
               <div class="message-input-container">
                  <input type="text" id="messageInput" class="message-input" placeholder="输入消息...">
               </div>
            </div>

            <div class="expression-area" id="expressionArea">
               <div class="expression-label">快速表情</div>
               <div class="expression-grid">
                  <button class="expression-btn" onclick="insertIntoInput('😊')">😊</button>
                  <button class="expression-btn" onclick="insertIntoInput('😏')">😏</button>
                  <button class="expression-btn" onclick="insertIntoInput('🤔')">🤔</button>
                  <button class="expression-btn" onclick="insertIntoInput('😎')">😎</button>
                  <button class="expression-btn" onclick="insertIntoInput('😰')">😰</button>
                  <button class="expression-btn" onclick="insertIntoInput('🙄')">🙄</button>
                  <button class="expression-btn" onclick="insertIntoInput('😤')">😤</button>
                  <button class="expression-btn" onclick="insertIntoInput('🤨')">🤨</button>
                  <button class="expression-btn" onclick="insertIntoInput('😮')">😮</button>
                  <button class="expression-btn" onclick="insertIntoInput('🤗')">🤗</button>
                  <button class="expression-btn" onclick="insertIntoInput('🤫')">🤫</button>
                  <button class="expression-btn" onclick="insertIntoInput('😈')">😈</button>
               </div>
            </div>

            <div class="expression-area" id="quickPanel">
               <div class="expression-label">快捷短语</div>
               <div class="quick-messages">
                  <button class="quick-msg-btn" onclick="insertIntoInput('我觉得你在撒谎！')">🔍 我觉得你在撒谎！</button>
                  <button class="quick-msg-btn" onclick="insertIntoInput('相信我，这是真的')">🤝 相信我，这是真的</button>
                  <button class="quick-msg-btn" onclick="insertIntoInput('让我想想...')">🤔 让我想想...</button>
                  <button class="quick-msg-btn" onclick="insertIntoInput('好险！')">😅 好险！</button>
               </div>
            </div>
         </div>
      </div>

      <!-- 游戏状态提示 ,这玩意以后肯定要删掉，仅供调试-->
      <div class="game-event-info" id="gameEventInfo">
         <h3>游戏事件信息</h3>
         <div id="eventMessages"></div>
         <button class="action-btn" onclick="clearEventMessages()">清除信息</button>
      </div>

   </div>
</body>
<script>
   //这里放那个加载页面的函数
   //首先是一个专场动画控制类
   class LoadingTransition {
      constructor() {
         this.overlay = document.getElementById('loading-overlay');
         this.textElement = document.getElementById('loading-text');

         this.isShowing = false;
      }

      // 开始转场动画
      show(text) {
         this.textElement.textContent = text;
         this.overlay.classList.add('show');
         this.isShowing = true;

         return new Promise(resolve => {
            // 等待动画完成后返回
            setTimeout(resolve, 300);
         });
      }

      // 结束转场动画
      hide() {
         this.overlay.classList.remove('show');
         this.isShowing = false;

         return new Promise(resolve => {
            // 等待动画完成后返回
            setTimeout(resolve, 300);
         });
      }

      // 更新加载文字
      updateText(text) {
         this.textElement.textContent = text;
      }

      // 检查是否正在显示
      isVisible() {
         return this.isShowing;
      }
   }

   // 创建全局转场动画实例
   const loadingTransition = new LoadingTransition();
   console.log(loadingTransition);

   // 带转场动画的页面切换函数（这里有同步方法，非常好）
   async function showScreenWithLoading(screenName, loadingText) {
      // 1. 显示加载动画
      await loadingTransition.show(loadingText || '切换页面中');

      // 2. 模拟一些处理时间（实际项目中可能是数据加载）
      await new Promise(resolve => setTimeout(resolve, 500));

      // 3. 执行页面切换
      switchScreen(screenName);

      // 4. 隐藏加载动画
      await loadingTransition.hide();
   }

   // 实际的页面切换逻辑
   function switchScreen(screenName) {
      console.log('切换到页面:', screenName);

      // 隐藏所有页面
      document.querySelectorAll('.screen').forEach(screen => {
         screen.classList.add('hidden');
      });

      // 显示目标页面
      const targetScreen = document.getElementById(screenName + '-screen');
      if (targetScreen) {
         targetScreen.classList.remove('hidden');
      }
   }
</script>
<script>
   //这里是界面初始化
   window.onload = function () {
      showScreenWithLoading("lobby", "加载游戏大厅中")

   }


</script>
<script>
   //一会考虑写一个从服务器端随机获得名字与ID与头像的函数（已经写好，但是缺足够头像）
   //接着我会补充一个gameState类，这个类会包含所有的游戏逻辑
   const expressions = ['😁', '😊', '😎', '🤔', '😏', '🙂'];
   const clothes = ['👗', '👔', '🦺', '👘', '🥻'];
   const accessories = ['🎩', '👑', '🎓', '👒', '🧢'];
   const leftItems = ['💰', '🗝️', '🎭', '🔍', '📜'];
   const rightItems = ['⚔️', '🛡️', '🏆', '💎', '🎯'];


   function updateLobbyPlayerInfo(playerInfo) {
      const { name, OverLook } = playerInfo;
      // 更新用户信息
      const userInfo = document.querySelector('.user-info .user-details h3');
      userInfo.textContent = name;

      // 更新角色展示区
      const characterHead = document.querySelector('.character-display .character-head');
      const characterClothes = document.querySelector('.character-display .character-clothes');
      const characterAccessory = document.querySelector('.character-display .character-accessory');
      const characterItemLeft = document.querySelector('.character-display .character-item-left');
      const characterItemRight = document.querySelector('.character-display .character-item-right');
      const characterName = document.querySelector('.character-display .character-name');

      characterHead.textContent = expressions[OverLook[0]];
      characterClothes.textContent = clothes[OverLook[1]];
      characterAccessory.textContent = accessories[OverLook[2]];
      characterItemLeft.textContent = leftItems[OverLook[3]];
      characterItemRight.textContent = rightItems[OverLook[4]];
      characterName.textContent = name;
   }

   function updateGameOpponentInfo(opponentInfos) {
      opponentInfos.forEach((opponentInfo, index) => {
         const { id, name, OverLook } = opponentInfo;
         const opponentElement = document.getElementById(`opponent${index + 1}`);
         if (opponentElement) {
            const opponentCharacterHead = opponentElement.querySelector('.character-head');
            const opponentCharacterClothes = opponentElement.querySelector('.character-clothes');
            const opponentCharacterAccessory = opponentElement.querySelector('.character-accessory');
            const opponentCharacterItemLeft = opponentElement.querySelector('.character-item-left');
            const opponentCharacterItemRight = opponentElement.querySelector('.character-item-right');
            const opponentName = opponentElement.querySelector('.opponent-name');

            opponentCharacterHead.textContent = expressions[OverLook[0]];
            opponentCharacterClothes.textContent = clothes[OverLook[1]];
            opponentCharacterAccessory.textContent = accessories[OverLook[2]];
            opponentCharacterItemLeft.textContent = leftItems[OverLook[3]];
            opponentCharacterItemRight.textContent = rightItems[OverLook[4]];
            opponentName.textContent = name;
            opponentName.dataset.player_id = id; // 添加 data-player_id 属性
            console.log(opponentName.dataset.player_id);
         }
      });
      console.log("我执行完了");
   }

   // 初始化渲染玩家自身形象和子弹数的函数
   function renderPlayerSelf() {
      const playerSelf = document.getElementById('playerSelf');
      const playerInfo = gameState.playerInfo;
      const gameManager = gameState.gameManager;

      // 更新玩家名称
      const playerName = playerSelf.querySelector('.player-name');
      playerName.textContent = playerInfo.name;

      // 更新玩家角色形象
      const playerCharacterHead = playerSelf.querySelector('.character-head');
      const playerCharacterClothes = playerSelf.querySelector('.character-clothes');
      const playerCharacterAccessory = playerSelf.querySelector('.character-accessory');
      const playerCharacterItemLeft = playerSelf.querySelector('.character-item-left');
      const playerCharacterItemRight = playerSelf.querySelector('.character-item-right');

      playerCharacterHead.textContent = expressions[playerInfo.OverLook[0]];
      playerCharacterClothes.textContent = clothes[playerInfo.OverLook[1]];
      playerCharacterAccessory.textContent = accessories[playerInfo.OverLook[2]];
      playerCharacterItemLeft.textContent = leftItems[playerInfo.OverLook[3]];
      playerCharacterItemRight.textContent = rightItems[playerInfo.OverLook[4]];

      // 更新玩家牌数量
      const playerCards = playerSelf.querySelector('.player-cards');
      playerCards.textContent = `${gameManager.hands.length} 张牌`;

      // 更新玩家子弹数（假设初始 6 颗子弹，可根据实际情况修改）
      const bullets = playerSelf.querySelectorAll('.bullet');
      const remainingBullets = gameState.gameManager.bullets; // 这里需要根据实际游戏逻辑修改
      bullets.forEach((bullet, index) => {
         bullet.classList.toggle('used', index >= remainingBullets);
      });
   }
   class GameState {
      constructor() {
         this.playerInfo = {
            id: 2233,  //这个无所谓，以后会从服务器端获取
            name: null,
            avatar: null,
            OverLook: [],
            isHost: false,
            isRobot: false

         },
            this.roomInfo = {
               roomId: null,
               playerList: [],
               updateList: function (playerList) {
                  this.playerList = playerList;
                  //更新玩家列表
                  Array.from(document.getElementById('playersDiv').querySelectorAll('#avatarsContainer img')).forEach((img, index) => {
                     if (index < playerList.length) {
                        img.src = `./assets/images/avatars/${playerList[index].avatar}`; // 更新头像
                        img.alt = playerList[index].name; // 更新名字 
                     }
                     else {
                        img.src = `./assets/images/avatars/avatar0.png`; // 更新头像
                        img.alt = ""; // 更新名字 
                     }
                  })
               }

            },
            this.gameManager = {
               gamePhase: 'waiting', // 'waiting', 'playing', 'challenge', 'roulette', 'over'
               targetCard: null,  // 当前目标牌: 'J', 'Q', 'K'
               currentPlayerId: null, // 当前出牌玩家ID
               lastPlayerId: null,    // 上一个出牌的玩家ID
               roulettePlayerId: null, // 正在轮盘赌的玩家ID
               roundNumber: 0,      // 当前回合数

               // 所有玩家信息 - 使用Map存储
               players: new Map(),    // playerId -> playerInfo
               eliminatedPlayers: [], // 已淘汰玩家ID集合

               // 我的信息
               hands: [],           // 我的手牌数组
               bullets: 6,           // 我的子弹数


               // 桌面信息
               //deskCards: [],       // 桌面卡牌信息
               lastPlayedCount: 0,  // 上次出牌数量
               lastDeclaredValue: null, // 上次声称的牌值
               lastActualCards: [],  // 上次实际出的牌（质疑后可见）
            }
         initPlayerInfo().then(playerData => {
            Object.assign(this.playerInfo, playerData);
            console.log(this.playerInfo);
            // 初始化完成后，更新玩家信息显示
            updateLobbyPlayerInfo(this.playerInfo);
         }).catch(error => {
            console.error('初始化玩家信息失败:', error);
         });
      }

   }
   //这里应该是从服务器端获取名字与ID与头像的函数 
   async function initPlayerInfo() {
      try {
         // 从服务器端获取名字与ID与头像的函数 
         const response = await fetch('http://localhost:3000/getRandomIdentity');
         // 检查响应状态是否正常
         if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
         }
         // 将响应数据解析为 JSON 格式
         const data = await response.json();
         // 处理返回的数据
         //返回的数据类型为res.json({ name: randomName, avatar: randomAvatar, OverLook: randomOverLook });
         console.log(data);
         return data;
      } catch (error) {
         console.error('获取玩家信息失败:', error);
         return {};
      }
   }

   const gameState = new GameState();

   // 点击按钮创建房间
   //创建房间的方式是，向后端发送一个请求，仅包括房主id
   //测试阶段，房主id固定为2233，后期会由数据库记录
   //后端将返回房间id，此时前端生成一个类似弹窗的页面，显示id和已经加入房间的人，还有x号
   //点击x号会有提示，之后退出房间，向后端发信息，之后房间销毁
   //人数达到4个后点击确定可以开始游戏，也可以点击人机模式，之后进入游戏页面

   //下面的创建房间啊之类的方法日后也能放在gameState里？
   function createRoom() {
      socket.emit('create_room', gameState.playerInfo.id); // 发送创建房间请求
   }



   function joinRoom() {
      // 获取房间ID
      const roomId = document.querySelector('.room-input').value;
      console.log(roomId);
      if (roomId) {
         // 发送加入房间请求
         socket.emit('join_room', {
            roomId,
            playerInfo: gameState.playerInfo
         });
         //注意一个问题，发送信息是 如果直接穿变量，前端后端名字应一致，要么就像这样 playerInfo:thisplayerInfo，后端用playerInfo接收
      }

   }

   function startGame() {
      if (gameState.playerInfo.isHost) {
         Swal.fire({
            title: '准备好了吗？',
            text: "人数不足四人时，将以机器人代替空缺玩家",
            icon: 'question',
            showCancelButton: true,
            confirmButtonColor: '#3085d6',
            cancelButtonColor: '#d33',
            confirmButtonText: '开始游戏',
            cancelButtonText: '取消'

         }).then((result) => {
            if (result.isConfirmed) {
               if (gameState.roomInfo.playerList.length < 4) {
                  // 如果人数不足4人，将自动添加机器人
                  const robotPromises = [];
                  for (let i = gameState.roomInfo.playerList.length; i < 4; i++) {
                     const robotInfo = {
                        id: gameState.playerInfo.id + "_robot" + i,
                        name: null,
                        avatar: null,
                        OverLook: null,
                        isHost: false,
                        isRobot: true
                     };
                     const promise = initPlayerInfo().then(playerData => {
                        Object.assign(robotInfo, playerData);
                        console.log(robotInfo);
                        socket.emit('join_room', {
                           roomId: gameState.roomInfo.roomId,
                           playerInfo: robotInfo
                        });
                     }).catch(error => {
                        console.error('初始化玩家信息失败:', error);
                     });
                     robotPromises.push(promise);
                  }

                  // 等待所有机器人信息初始化完成
                  Promise.all(robotPromises).then(() => {
                     document.getElementById('playersDiv').remove();
                     // 加载游戏页面
                     showScreenWithLoading('game', '加载游戏页面中');
                     

                     socket.emit('start_game', { roomId: gameState.roomInfo.roomId }); // 发送开始游戏请求
                  });
               } else {
                  document.getElementById('playersDiv').remove();
                  
                  socket.emit('start_game', { roomId: gameState.roomInfo.roomId }); // 发送开始游戏请求
                  // 加载游戏页面
                  showScreenWithLoading('game', '加载游戏页面中');
                  //延迟一秒后
                  setTimeout(() => {
                     // 加载游戏页面
                     showScreenWithLoading('game', '更新角色形象中'); 
                  },1000);
               }
            }
            else {
               Swal.fire({
                  title: '已取消',
                  icon: 'error',
                  confirmButtonColor: '#3085d6',
                  confirmButtonText: '确定'
               });
            }
         })



      }
      else {
         Swal.fire({
            title: '你不是房主，无法开始游戏',
            icon: 'error',
            confirmButtonColor: '#3085d6',
            confirmButtonText: '确定'
         });
      }
   }
   function closeDiv() {
      //弹窗:你确认要退出房间吗？
      if (gameState.playerInfo.isHost) {
         Swal.fire({
            title: '你确认要退出房间吗？',
            text: "房间会被销毁，其他玩家也会被踢出房间",
            icon: 'warning',
            showCancelButton: true,
            confirmButtonColor: '#3085d6',
            cancelButtonColor: '#d33',
            confirmButtonText: '退出',
            cancelButtonText: '取消'
         }).then((result) => {
            if (result.isConfirmed) {
               //删除房间
               document.getElementById('playersDiv').remove();
               localStorage.removeItem('roomId'); // 从本地存储中移除房间ID
               // socket.emit('close_room', { roomId: localStorage.getItem('roomId') }); // 发送关闭房间请求
               //这一部分后端还没写
            }
         });


      } else {
         Swal.fire({
            title: '你确认要退出房间吗？',
            icon: 'warning',
            showCancelButton: true,
            confirmButtonColor: '#3085d6',
            cancelButtonColor: '#d33',
            confirmButtonText: '退出',
            cancelButtonText: '取消'
         }).then((result) => {
            if (result.isConfirmed) {
               document.getElementById('playersDiv').remove();

            }
         });

      }
   }
   //创建房间/加入房间成功后或加入游戏成功后展示一个房间加入页面（div）(本来存在但隐藏)
   //隐藏的好处是，不用担心dom创建过程时导致异步操作
   function intiDiv(roomId) {
      const players_Div = document.getElementById('playersDiv');
      players_Div.style.display = 'flex';
      players_Div.querySelector('#roomIDspan').innerHTML = `房间ID: ${roomId}`;
      //在这里添加一下监听器，一个是关闭，一个是开始游戏
      players_Div.querySelector('#closeButton').addEventListener('click', () => {
         console.log("关闭按钮被点击");
         closeDiv(); // 调用关闭函数
      });
      players_Div.querySelector('#startButton').addEventListener('click', () => {
         console.log("开始游戏按钮被点击");
         startGame(); // 调用开始游戏函数
      });
      //如果玩家非房主的话，隐藏开始游戏按钮
      if (!gameState.playerInfo.isHost) {
         players_Div.querySelector('#startButton').style.display = 'none';
      }
   }
   // 好友列表切换
   function toggleFriends() {
      const sidebar = document.getElementById('friendsSidebar');
      sidebar.classList.toggle('open');
   }
</script>
<script>
   socket.on('room_created', (roomId) => {
      console.log(`Room created with ID: ${roomId}`); // 接收创建成功的消息 
      gameState.playerInfo.isHost = true; //更新房主身份
      localStorage.setItem('roomId', roomId); //把房间ID保存到本地存储中
      socket.emit('join_room', {
         roomId,
         playerInfo: gameState.playerInfo
      }); // 发送加入房间请求
      console.log("发送了加入房间请求");
   })

   socket.on('room_joined', (data) => {
      //如果id字段中有_robot
      if (String(data.id).includes('_robot')) {

      }
      else {
         console.log(`Joined room with ID: ${data.roomId}`); // 接收加入成功的消息
         localStorage.setItem('roomId', data.roomId); //把房间ID保存到本地存储中
         gameState.roomInfo.roomId = data.roomId; //更新房间ID
         gameState.playerInfo.id = data.id; //更新玩家ID
         intiDiv(gameState.roomInfo.roomId); //初始化房间加入页面
      }

   })

   //接收广播的玩家加入事件，用于同步更新玩家加入界面，我认为这里应该直接发过来玩家列表数组
   socket.on('player_joined', (data) => {

      const playerlist = data.playerList; //获取玩家列表
      const playerInfo = data.playerInfo; //获取玩家信息
      console.log(`Player joined: ${playerInfo.name}`); // 接收玩家加入的消息
      if (playerInfo.isRobot) {

      }
      else {
         //显示玩家加入的弹窗
         Swal.fire({
            position: 'center',
            icon: 'info',
            title: `${playerInfo.name} 加入了房间`,
            showConfirmButton: false,
            timer: 1500
         });
      }

      //console.log(playerlist);
      gameState.roomInfo.updateList(playerlist); //更新玩家列表
   })

   socket.on('error', (errorInfo) => {
      Swal.fire({
         title: errorInfo,
         icon: 'warning',
         confirmButtonColor: '#3085d6',
         confirmButtonText: '确认',
      })
   })

   socket.on('game_started', (data) => {
      //显示弹窗
      Swal.fire({
         position: 'center',
         title: '游戏开始',
         icon: 'success',
         showConfirmButton: false,
         timer: 500


      })
      console.log("游戏开始");
      renderPlayerSelf();
      const opponentInfos = gameState.roomInfo.playerList.filter(player => player.id !== gameState.playerInfo.id);; //获取对手信息
      updateGameOpponentInfo(opponentInfos);
   });

   socket.on('round_started', (data) => {
      //需要一个数据类型去记录目标牌和手牌了
      gameState.gameManager.targetCard = data.targetCard; //更新目标牌
      set_target(data.targetCard); //更新目标牌
      console.log("目标牌：" + gameState.gameManager.targetCard);
      showGameEventMessage("目标牌：" + gameState.gameManager.targetCard);
      socket.emit('deal_cards', { playerId: gameState.playerInfo.id, roomId: gameState.roomInfo.roomId }); //发送发牌请求
      console.log("发送了发牌请求");
      showGameEventMessage("发送了发牌请求");

   })
   socket.on('cards_dealt', (data) => {
      gameState.gameManager.hands = data; //更新已出的牌
      console.log(data);
      console.log("收到了发牌信息");
      showGameEventMessage("收到了发牌信息");
      console.log(gameState.gameManager.hands);
      setTimeout(() => { if (dealCards()) setTimeout(drawCard, 1300) }, 500);
      //发牌动画
   });
   socket.on('start_timer', (timestamp) => {
      showGameEventMessage("开始倒计时");
      const timerElement = document.getElementById('timer');
      if (!timerElement) return;

      // 清除现有定时器
      if (timerInterval) {
         clearInterval(timerInterval);
      }
      const now = Date.now();
      const delay = timestamp - now;

      // 如果时间戳已经过去，立即开始倒计时
      if (delay <= 0) {
         startCountdown(timerElement);
      } else {
         // 在指定时间戳触发倒计时
         setTimeout(() => {
            startCountdown(timerElement);
         }, delay);
      }
   });

   socket.on('sync_game_state', (state) => {
      Object.assign(gameState.gameManager, state);

      // 把 players 更新进 Map 格式
      const map = new Map();
      for (let p of state.players) {
         map.set(p.id, p);
      }
      gameState.gameManager.players = map;
      showGameEventMessage("收到了同步信息");
      // 根据 phase 控制 UI 显示
      updateUI();
   });
   
   socket.on('cards_played', (data) => {
      if(data.playerId===gameState.playerInfo.id){
        //是自己出的牌，不需要动画 
      }
      else{
         playOpponentCards(data.playerId, data.cardsNum);
      }
   });
socket.on('challenge_result', (data) => {
   showGameEventMessage("收到了质疑结果");}
   //首先触发质疑动画
   //接着触发翻牌动画
   //接着触发成功/失败动画
)



   //接下来首先把game界面自身的一些测试函数给去掉
   //然后呢，我们就去写发牌，取牌，出牌等等的前后端逻辑，确保能玩
   //至于页面上需要调整的，到时候再说吧
   //然后呢，适当把代码拆分一下
</script>
<script>
   //以下是游戏界面的初始化和动画的代码，我认为肯定存在大量冗余，以后改
   //而且有些函数的逻辑本该属于后端，再说吧
   toggleChat();
   document.getElementById('playedCards').style.visibility = 'hidden';
   //const allcard = ["A", "Q", "K"];
   //const play1 = ["A", "Q", "K", "joker", "joker"];（均已丧失作用）
   let selectedCards = [];
   let timerInterval;
   let currentTime;

   //const deck = initDeck();
   //initdeck已经删掉了，没一点用
   // 图片对象
   const cardImages = {
      'A': new Image(),
      'Q': new Image(),
      'K': new Image(),
      'joker': new Image(),
      'back': new Image()
   };
   const cardImagePaths = {
      'A': './assets/images/cards/A.png',
      'Q': './assets/images/cards/Q.png',
      'K': './assets/images/cards/K.png',
      'joker': './assets/images/cards/joker.png',
      'back': './assets/images/cards/card_back.png'
   };
   // 跟踪已加载的图片数量
   let loadedImages = 0;
   const totalImages = Object.keys(cardImages).length;

   // 加载所有图片并在全部完成后初始化游戏
   function loadImages() {
      console.log('开始加载图片');
      for (const [key, image] of Object.entries(cardImages)) {
         image.onload = () => {
            loadedImages++;
            console.log(`${key} 图片加载完成`);
            if (loadedImages === totalImages) {
               console.log('所有图片加载完成，初始化游戏');
               //是先画目标牌吗？然后渲染手牌，然后是在渲染手牌中加了一句显示目标牌的？
               //目标牌的渲染有些重复了，所以第二个我会改一下就是newround函数
               //同时上来就直接发牌不行，我会把这一步放在其他地方的
               drawtargetCard();
               //setTimeout(() => { if (dealCards()) setTimeout(drawCard, 1300) }, 500);
               //我明白这一行是干啥的了，就是先触发发牌动画，然后渲染手牌
            }
            else {
               console.log(`还有 ${totalImages - loadedImages} 张图片未加载`);
            }
         };
         image.onerror = (error) => {
            console.error(`加载图片 ${key} 失败:`, error);
         };
         image.src = cardImagePaths[key];
      }
   }
   //目标牌绘制（背景） 
   function drawtargetCard() {
      const targetArea = document.getElementById('targetCard');

      // 清空现有内容
      targetArea.innerHTML = '';

      // 创建Canvas元素
      const targetcanvas = document.createElement('canvas');
      targetcanvas.width = 50;
      targetcanvas.height = 75;
      targetArea.appendChild(targetcanvas);
      const ctx = targetcanvas.getContext('2d');
      ctx.drawImage(cardImages['back'], 0, 0, targetcanvas.width, targetcanvas.height);
      window.targetctx = ctx; // 存储上下文以便后续使用

   }
   //选出目标牌，与目标牌绘制（背景）有重复逻辑，这里由newround改为set_target()(英文有问题先不管了)
   //就是现有一个局内信息的记录和更新，再把目标牌类型传递过来，就这样，over（已解决）
   function set_target(nowcard) {
      const targetArea = document.getElementById('targetCard');
      // 清空现有内容
      targetArea.innerHTML = '';

      const targetcanvas = document.createElement('canvas');
      targetcanvas.width = 50;
      targetcanvas.height = 75;
      targetcanvas.className = `card ${nowcard}`;
      targetArea.appendChild(targetcanvas);
      const ctx = targetcanvas.getContext('2d');
      ctx.drawImage(cardImages['back'], 0, 0, targetcanvas.width, targetcanvas.height);

      // 调用翻牌动画
      setTimeout(() => {
         flipCard(ctx, targetcanvas.width, targetcanvas.height, nowcard);
      }, 1000);
      //Timer();
   }
   //翻转牌动画
   function flipCard(ctx, width, height, nowcard) {
      cardFlipping = true;

      let angle = 0;
      const totalFrames = 30; // 动画总帧数
      const frameDuration = 16; // 每帧持续时间（ms）

      function animate() {
         angle += Math.PI / totalFrames;

         // 清除画布
         ctx.clearRect(0, 0, width, height);

         // 保存当前上下文状态
         ctx.save();
         // 应用变换
         ctx.translate(width / 2, height / 2);
         ctx.scale(Math.abs(Math.cos(angle)), 1);
         ctx.rotate(angle);
         ctx.rotate(angle);
         // 绘制牌
         if (angle < Math.PI / 2) {
            // 显示牌背面
            ctx.drawImage(cardImages['back'], -width / 2, -height / 2, width, height);
         } else {
            // 显示牌正面
            ctx.drawImage(cardImages[nowcard], -width / 2, -height / 2, width, height);
         }

         // 恢复上下文状态
         ctx.restore();

         // 继续动画
         if (angle < Math.PI) {
            requestAnimationFrame(animate);
         } else {
            // 动画完成
            isCardFlipped = true;
            cardFlipping = false;
         }
      }

      // 开始动画
      requestAnimationFrame(animate);
   }
   //出牌

   // 玩家位置（这个肯定要替换掉）
   const playersPos = [
      {
         id: 'opponent1',
         hand: [],
         // 顶部对手：水平居中，垂直 60px（与 CSS 的 top: 60px 一致）
         position: {
            x: window.innerWidth / 2,
            y: 60
         }
      },
      {
         id: 'opponent2',
         hand: [],
         // 左侧对手：水平 28% 宽度处，垂直居中（与 CSS 的 left: 28% 一致）
         position: {
            x: window.innerWidth * 0.28,
            y: window.innerHeight / 2
         }
      },
      {
         id: 'opponent3',
         hand: [],
         // 右侧对手：水平 72% 宽度处（100% - 28%），垂直居中
         position: {
            x: window.innerWidth * 0.72,
            y: window.innerHeight / 2
         }
      },
      {
         id: 'player1',
         hand: [],
         // 玩家自己：水平居中，垂直底部 100px（保持原逻辑）
         position: {
            x: window.innerWidth / 2,
            y: window.innerHeight - 100
         }
      }
   ];

   // 初始化牌堆Canvas（绘制牌背）
   function initDeckCanvas() {
      const playCards = document.getElementById('playedCards');
      playCards.style.visibility = 'visible';
      const stx = document.createElement('div');
      stx.className = 'played-card';
      const canvas = document.createElement('canvas');
      canvas.width = 40;
      canvas.height = 56;
      const ctx = canvas.getContext('2d');
      ctx.drawImage(cardImages['back'], 0, 0, canvas.width, canvas.height);
      playCards.style.visibility = 'visible';
      stx.appendChild(ctx.canvas);
      playCards.appendChild(stx);

   }
   // 发牌动画主函数
   function dealCards() {
      initDeckCanvas(); // 初始化牌堆显示
      playersPos.forEach((player, index) => {
         // 每个玩家发5张牌
         for (let i = 0; i < 5; i++) {
            //const cardValue = deck.pop();
            //这行不知道为什么，没用，那么初始手牌是如何加载的呢？哦好像是写死的
            setTimeout(() => {
               // 从牌堆位置平移到目标位置
               const startPos = { x: window.innerWidth / 2, y: window.innerHeight / 2 }; // 牌堆中心
               const endPos = getPlayerHandPosition(player, i); // 计算手牌位置

               // 创建临时Canvas绘制单张牌
               const tempCanvas = document.createElement('canvas');
               tempCanvas.width = 60;
               tempCanvas.height = 90;
               const tempCtx = tempCanvas.getContext('2d');
               tempCtx.drawImage(cardImages['back'], 0, 0, 60, 90);

               // 执行平移动画
               animateCardTranslation(tempCanvas, startPos, endPos, () => {
                  tempCanvas.remove();
               });
            }, index * 100 + i * 200); // 延迟控制发牌顺序
         }
      });
      return 1;
   }

   // 计算手牌位置（横向排列）
   function getPlayerHandPosition(player, index) {
      const baseX = player.position.x;
      const baseY = player.position.y;
      const offsetX = 0;
      return { x: baseX + offsetX, y: baseY };
   }

   // 平移动画函数
   function animateCardTranslation(canvas, start, end, callback) {
      const ctx = canvas.getContext('2d');
      const duration = 300; // 动画时长（ms）
      const startTimestamp = performance.now();

      function update(timestamp) {
         let progress = (timestamp - startTimestamp) / duration;
         if (progress > 1) progress = 1;

         // 线性插值计算当前位置
         const currentX = start.x + (end.x - start.x) * progress;
         const currentY = start.y + (end.y - start.y) * progress;

         // 绘制当前帧
         drawCardAtPosition(canvas, currentX, currentY);

         if (progress < 1) {
            requestAnimationFrame(update);
         } else {
            callback(); // 动画完成回调
         }
      }
      requestAnimationFrame(update);
   }

   // 在指定位置绘制卡牌
   function drawCardAtPosition(canvas, x, y) {
      const tempDiv = document.createElement('div');
      tempDiv.style.position = 'absolute';
      tempDiv.style.zIndex = 999;
      tempDiv.style.left = `${x}px`;
      tempDiv.style.top = `${y}px`;
      tempDiv.appendChild(canvas);
      document.body.appendChild(tempDiv);
   }

   //渲染卡牌
   // (这个到底是干嘛的？以及最初的发牌动画到底是谁干的？)
   //（这个其实是针对手牌的渲染）
   function drawCard() {
      const playedCards = document.getElementById('playedCards');
      playedCards.innerHTML = '';
      playedCards.style.visibility = 'hidden';
      const handCards = document.getElementById('handCards');
      gameState.gameManager.hands.forEach(({ id: cardId, value: cardValue }) => {
         const cardContainer = document.createElement('div');
         cardContainer.className = 'hand-card';
         cardContainer.dataset.value = cardValue;
         cardContainer.dataset.clicked = "false"; // 初始化点击状态
         cardContainer.dataset.id = cardId;

         const frontCanvas = document.createElement('canvas');
         frontCanvas.width = 70;
         frontCanvas.height = 100;
         const frontCtx = frontCanvas.getContext('2d');
         const cardImage = cardImages[cardValue];


         frontCtx.drawImage(cardImage, 0, 0, frontCanvas.width, frontCanvas.height);


         cardContainer.appendChild(frontCanvas);
         handCards.appendChild(cardContainer);
         cardContainer.addEventListener('click', handleCardClick);
      })
      //为什么要放在这里捏，注释掉看看效果
      //newround();
      //注释掉后就不能加载目标牌了
      //那么这个渲染卡牌指的是渲染手牌吗？我再看看，是的
      //我认为逻辑应该是，先接收到game_start的消息，然后显示一个小动画
      //然后是获取目标牌round_started（之后绘制）和发牌（发deal_cards请求，接收cards_dealt）
   }


   // 处理卡牌点击事件
   function handleCardClick(event) {
      const currentPlayerId = gameState.gameManager.currentPlayerId;
      const myPlayerId = gameState.playerInfo.id;
      const isMyTurn = currentPlayerId === myPlayerId;

      // 若不是自己回合，不处理点击事件
      if (!isMyTurn) {
         return;
      }
      const card = event.currentTarget;
      const isSelected = card.classList.contains('selected');

      // 如果已选卡牌达到3张且当前卡牌未选中，则不处理点击
      if (selectedCards.length >= 3 && !isSelected) {
         return;
      }

      // 切换选中状态
      if (isSelected) {
         card.classList.remove('selected');
         card.style.transform = 'translateY(0)';
         // 从已选列表中移除
         selectedCards = selectedCards.filter(c => c !== card);
      } else {
         card.classList.add('selected');
         card.style.transform = 'translateY(-15px)';
         // 添加到已选列表
         selectedCards.push(card);
      }

      // 更新自定义属性
      card.dataset.clicked = isSelected ? "false" : "true";

      // 更新出牌按钮状态
      updatePlayButtonState();
   }
   // 更新出牌按钮状态
   function updatePlayButtonState() {
      const playSelectedButton = document.getElementById('playBtn');
      if (selectedCards.length > 0 && selectedCards.length <= 3) {
         playSelectedButton.disabled = false;
         playSelectedButton.classList.remove('opacity-50', 'cursor-not-allowed');
      } else {
         playSelectedButton.disabled = true;
         playSelectedButton.classList.add('opacity-50', 'cursor-not-allowed');
      }
   }
   // 播放卡牌动画(哦原来这个就是出牌的函数),把socket.emit放在这里了
   function playSelectedCards() {
      if (selectedCards.length === 0) return;
      // 获取窗口尺寸
      const windowWidth = window.innerWidth;
      const windowHeight = window.innerHeight;

      const playedCardsArea = document.getElementById('playedCards');
      // 清除提示文本
      if (playedCardsArea.querySelector('p')) {
         playedCardsArea.innerHTML = '';
      }

      const targetPositions = [];
      const cardWidth = 70; // 卡牌宽度
      const gap = 8; // 卡牌间距
      const totalWidth = selectedCards.length * cardWidth + (selectedCards.length - 1) * gap;
      const startX = (playedCardsArea.offsetWidth - totalWidth) / 2;

      for (let i = 0; i < selectedCards.length; i++) {
         targetPositions.push({
            x: startX + i * (cardWidth + gap),
            y: playedCardsArea.offsetHeight - 450
         });
      }
      // 提取选中卡牌的 id 和 value
      const selectedCardData = selectedCards.map(card => ({
         id: card.dataset.id, // 假设元素有 data-id 属性
         value: card.dataset.value
      }));

      // 发送选中卡牌数据到后端
      socket.emit('play_cards', {
         playerId: gameState.playerInfo.id,
         roomId: gameState.roomInfo.roomId,
         cards: selectedCardData
      });
      showGameEventMessage("发送了出牌信息");
      console.log(selectedCardData);


      // 保存原始卡牌数据并开始动画
      const originalCards = [...selectedCards];
      const originalCardValues = originalCards.map(card => card.dataset.value);

      // 开始动画
      animateCardsToPlayArea(originalCards, targetPositions, () => {
         // 动画结束后，添加到已打出区域
         playedCardsArea.innerHTML = '';
         originalCards.forEach((card, index) => {
            card.style.transform = 'none';
            card.classList.remove('selected');
            playedCardsArea.appendChild(card);
         });

         // 从手牌中移除已打出的卡牌
         const handCardsArea = document.getElementById('handCards');
         originalCards.forEach(card => {
            if (handCardsArea.contains(card)) {
               handCardsArea.removeChild(card);
            }
         });

         // 重置已选卡牌
         selectedCards = [];
         updatePlayButtonState();

         // 绘制等量的卡牌背面
         for (let i = 0; i < originalCards.length; i++) {
            initDeckCanvas();
         }
      });
      //Timer();
   }

   // 卡牌动画函数
   function animateCardsToPlayArea(cards, targetPositions, callback) {
      const duration = 800; // 动画持续时间（毫秒）
      const startTime = performance.now();

      // 获取初始位置
      const startPositions = cards.map(card => {
         const rect = card.getBoundingClientRect();
         const parentRect = document.getElementById('playedCards').getBoundingClientRect();
         return {
            x: rect.left - parentRect.left,
            y: rect.top - parentRect.top
         };
      });

      // 确保所有卡牌的初始位置都是正确的
      cards.forEach(card => {
         const rect = card.getBoundingClientRect();
         card.style.position = 'absolute';
         card.style.left = `${rect.left}px`;
         card.style.top = `${rect.top}px`;
         card.style.zIndex = '10';

         // 确保父容器是相对定位
         document.getElementById('playedCards').style.position = 'relative';
         document.body.appendChild(card);
      });

      // 动画循环
      function animate(currentTime) {
         const elapsedTime = currentTime - startTime;
         const progress = Math.min(elapsedTime / duration, 1);
         const easeProgress = easeOutCubic(progress);

         cards.forEach((card, index) => {
            const startPos = startPositions[index];
            const targetPos = targetPositions[index];

            // 计算当前位置
            const currentX = startPos.x + (targetPos.x - startPos.x) * easeProgress;
            const currentY = startPos.y + (targetPos.y - startPos.y) * easeProgress;

            // 应用变换
            card.style.transform = `translate(${currentX}px, ${currentY}px)`;
         });

         if (progress < 1) {
            requestAnimationFrame(animate);
         } else {
            // 动画完成
            callback();
         }
      }

      // 开始动画
      requestAnimationFrame(animate);
   }

   // 缓动函数
   function easeOutCubic(t) {
      return 1 - Math.pow(1 - t, 3);
   }
   //倒计时（是旧的，已经作废）
   function Timer() {
      const timerElement = document.getElementById('timer');
      if (!timerElement) return;

      // 清除现有定时器
      if (timerInterval) {
         clearInterval(timerInterval);
      }

      // 重置时间
      currentTime = 30;
      timerElement.textContent = currentTime;

      // 创建新定时器
      timerInterval = setInterval(updateTimer, 1000);

      function updateTimer() {
         currentTime--;
         timerElement.textContent = currentTime;

         if (currentTime <= 0) {
            clearInterval(timerInterval);
            timerElement.textContent = '时间到！';
         }
      }
   }



   // 缓动函数（辅助倒计时）
   function easeOutCubic(t) {
      return 1 - Math.pow(1 - t, 3);
   }
   // 开始倒计时的函数
   function startCountdown(timerElement) {
      // 重置时间
      currentTime = 15;
      timerElement.textContent = currentTime;

      // 创建新定时器
      timerInterval = setInterval(updateTimer, 1000, timerElement);
   }

   // 更新倒计时的函数
   function updateTimer(timerElement) {
      currentTime--;
      timerElement.textContent = currentTime;

      if (currentTime <= 0) {
         clearInterval(timerInterval);
         timerElement.textContent = '时间到！';
         // 倒计时结束，发送 timer_ended 事件
         socket.emit('timer_ended');
      }
   }
   //表情及聊天
   function toggleChat() {
      const chatContent = document.getElementById('chatContent');
      const toggleBtn = document.querySelector('.chat-toggle');

      if (chatContent.style.display === 'none') {
         chatContent.style.display = 'flex';
         toggleBtn.textContent = '−';
      } else {
         chatContent.style.display = 'none';
         toggleBtn.textContent = '+';
      }
   }

   // 切换表情面板显示/隐藏
   function toggleEmojiPanel() {
      const emojiPanel = document.getElementById('expressionArea');
      const toggleBtn = document.getElementById('toggle-emoji-btn');

      if (emojiPanel.style.display === 'none' || emojiPanel.style.display === '') {
         emojiPanel.style.display = 'block';
         toggleBtn.innerHTML = '🙊 隐藏表情';
         document.getElementById('quickPanel').style.display = 'none';
         document.getElementById('toggle-quick-btn').innerHTML = '💬 显示短语'; // 修正这里
      } else {
         emojiPanel.style.display = 'none';
         toggleBtn.innerHTML = '😀 显示表情';
      }
   }

   // 切换快捷短语面板显示/隐藏
   function toggleQuickPanel() {
      const quickPanel = document.getElementById('quickPanel');
      const toggleBtn = document.getElementById('toggle-quick-btn');

      if (quickPanel.style.display === 'none' || quickPanel.style.display === '') {
         quickPanel.style.display = 'block';
         toggleBtn.innerHTML = '🙊 隐藏短语';
         document.getElementById('expressionArea').style.display = 'none';
         document.getElementById('toggle-emoji-btn').innerHTML = '😀 显示表情'; // 修正这里
      } else {
         quickPanel.style.display = 'none';
         toggleBtn.innerHTML = '💬 显示短语';
      }
   }

   // 插入内容到输入框
   function insertIntoInput(content) {
      const input = document.getElementById('messageInput');
      input.value += content;
      input.focus();
   }

   // 发送文本消息
   function sendMessage() {
      const input = document.getElementById('messageInput');
      const message = input.value.trim();
      if (message) {
         appendMessage(message);
         input.value = ''; // 清空输入框
         document.getElementById('expressionArea').style.display = 'none';
         document.getElementById('quickPanel').style.display = 'none';
         document.getElementById('toggle-emoji-btn').innerHTML = '😀 显示表情';
         document.getElementById('toggle-quick-btn').innerHTML = '💬 显示短语';

      }
   }

   // 追加消息到聊天窗口
   function appendMessage(content) {
      const chatMessages = document.getElementById('chatMessages');
      const newMessage = document.createElement('div');
      newMessage.className = 'chat-message player';
      newMessage.textContent = '你: ' + content;
      chatMessages.appendChild(newMessage);

      // 滚动到底部
      chatMessages.scrollTop = chatMessages.scrollHeight;
   }

   // 支持按Enter发送消息
   document.getElementById('messageInput').addEventListener('keypress', function (e) {
      if (e.key === 'Enter') {
         sendMessage();
      }
   });


   //这是之前的版本，要改掉，拆分成1.质疑动画2.翻牌动画3.成功/失败动画
   //翻转牌，并通过判断是否渲染开枪动画
   function challenge() {

      function checkcard() {
         const playedCards = document.getElementById('playedCards');
         const cardElements = playedCards.querySelectorAll('.played-card canvas');

         // 逐个翻转卡牌
         cardElements.forEach((canvas, index) => {
            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;

            // 延迟执行，使卡牌逐个翻转
            setTimeout(() => {
               // 选择对应的卡牌正面图像;
               flipCard(ctx, width, height, 'A');//卡牌正面直接设置为A，需要从玩法中的桌子中牌来重新设置
            }, index * 200); // 每张卡牌间隔200ms
         });
         if (1) return cardElements.length;//加入判断逻辑，质疑是否成功
      }
      //进行开枪测试
      function gun() {


         var buffer = document.getElementById('opponent2')
         var right = buffer.querySelector('.character-item-right')
         var head = buffer.querySelector('.character-head')
         const rightoriginal = right.textContent
         const headoriginal = head.textContent
         right.textContent = '🔫'
         head.textContent = '😱'
         right.classList.add('gun-animation');
         // 动画结束后改变头部为骷髅
         right.addEventListener('animationend', function animationEndHandler() {
            const isDead = Math.random() > 0.833;
            if (isDead) {
               head.textContent = '💀';
               right.textContent = '⚰️';
            }
            else {
               head.textContent = headoriginal
               right.textContent = rightoriginal
            }
            right.classList.remove('gun-animation');
            right.removeEventListener('animationend', animationEndHandler);
         });
      }

      const isChallengeSuccess = checkcard();
      if (isChallengeSuccess != 0) {
         setTimeout(gun, (isChallengeSuccess + 1) * 200);
         setTimeout(() => {
            const playedCards = document.getElementById('playedCards');
            playedCards.innerHTML = '';
            playedCards.style.visibility = 'hidden';
         }, (isChallengeSuccess + 2) * 200);
      }
      else {
         setTimeout(() => {
            const playedCards = document.getElementById('playedCards');
            playedCards.innerHTML = '';
            playedCards.style.visibility = 'hidden';
         }, (isChallengeSuccess + 1) * 200);
      }

   }

   // 显示游戏事件信息的函数
   function showGameEventMessage(message) {
      const eventMessagesDiv = document.getElementById('eventMessages');
      const newMessage = document.createElement('p');
      newMessage.textContent = message;
      eventMessagesDiv.appendChild(newMessage);
      // 自动滚动到最新消息
      eventMessagesDiv.scrollTop = eventMessagesDiv.scrollHeight;
   }

   // 清除游戏事件信息的函数
   function clearEventMessages() {
      const eventMessagesDiv = document.getElementById('eventMessages');
      eventMessagesDiv.innerHTML = '';
   }

   function updateUI() {
      //会根据gameState来更新UI 
      const playBtn = document.getElementById('playBtn');
      const challengeBtn = document.getElementById('challengeBtn');
      const selectionInfo = document.getElementById('selectionInfo');
      const currentPlayerId = gameState.gameManager.currentPlayerId;
      const myPlayerId = gameState.playerInfo.id;

      //好神奇，为什么我的ID变成robot了？
      //我想我知道了，因为robot加入房间也会发送room_joined消息，所以会更新id
      showGameEventMessage(`当前玩家ID:${currentPlayerId}`);
      // 判断是否为自己的回合
      const isMyTurn = currentPlayerId === myPlayerId;

      // 根据是否为自己的回合来启用或禁用按钮
      playBtn.disabled = !isMyTurn;
      challengeBtn.disabled = !isMyTurn;

      // 更新按钮的样式，使其在禁用状态下有视觉反馈
      if (!isMyTurn) {
         playBtn.classList.add('opacity-50', 'cursor-not-allowed');
         challengeBtn.classList.add('opacity-50', 'cursor-not-allowed');
         selectionInfo.textContent = "不是你的回合";

      } else {
         playBtn.classList.remove('opacity-50', 'cursor-not-allowed');
         challengeBtn.classList.remove('opacity-50', 'cursor-not-allowed');
         selectionInfo.textContent = "你的回合，请选择";
         showGameEventMessage("你的回合开始了");
      }
      const allOpponentElements = document.querySelectorAll('.opponent');

      allOpponentElements.forEach(opponentElement => {
         //确定当前玩家
         //console.log("我开始执行了");
         //所以应该不是次序的问题
         const opponentName = opponentElement.querySelector('.opponent-name');
         const playerId = opponentName?.dataset.player_id;
         if (playerId === String(currentPlayerId)) {
            opponentElement.classList.add('active');
            console.log(`${opponentName.textContent}的回合开始了`);
         } else {
            opponentElement.classList.remove('active');
         }
         //下面这些似乎没有正常运行，而且在回合开始的时候也没有运行，不理解
         //我知道为什么了，就是因为update函数居然发生在游戏角色初始化之前
         //那么这样铁定被重绘啊
         // 更新每个对手手牌数
         const opponentInfo = gameState.gameManager.players.get(playerId);
         if (opponentInfo) {
            const opponentCards = opponentElement.querySelector('.opponent-cards');
            if (opponentCards) {
               opponentCards.textContent = `${opponentInfo.handCount} 张牌`;
            }

            // 更新每个对手剩余子弹数
            const opponentBullets = opponentElement.querySelectorAll('.bullet');
            opponentBullets.forEach((bullet, index) => {
               bullet.classList.toggle('used', index >= opponentInfo.bulletCount);
            });
         }
         else {
            console.log(`未找到玩家 ${playerId} 的信息`);
         }

      });
      const playerSelf = document.getElementById('playerSelf');
      if (playerSelf) {
         const playerCards = playerSelf.querySelector('.player-cards');
         if (playerCards) {
            playerCards.textContent = `${gameState.gameManager.players.get(gameState.playerInfo.id).handCount} 张牌`;
         }
         else {
            console.log(`未找到玩家 ${playerId} 的信息`); 
         }

         // 更新玩家自身剩余子弹数
         const playerBullets = playerSelf.querySelectorAll('.bullet');
         playerBullets.forEach((bullet, index) => {
            bullet.classList.toggle('used', index >= gameState.gameManager.bullets);
         });
      }
      else {
         console.log(`未找到玩家 ${playerId} 的信息`); 
      }
   }

 // 处理其他玩家出牌动画的函数
 // 处理对手出牌动画的函数

// 处理对手出牌动画的函数
// 处理对手出牌动画的函数
function playOpponentCards(playerId, cardsCount) {
    if (cardsCount <= 0) return;
    
    // 1. 找到对手元素
    const opponentElement = document.querySelector(`.opponent-name[data-player_id="${playerId}"]`);
    if (!opponentElement) {
        console.error(`找不到玩家 ${playerId} 的元素`);
        return;
    }
    
    const opponentContainer = opponentElement.closest('.opponent');
    const playedCardsArea = document.getElementById('playedCards');
    
    // 2. 清除桌面现有卡牌
    if (playedCardsArea.querySelector('p')) {
        playedCardsArea.innerHTML = '';
    }
    
    // 3. 计算目标位置（桌面中央的卡牌排列位置）
    const cardWidth = 70;
    const gap = 8;
    const totalWidth = cardsCount * cardWidth + (cardsCount - 1) * gap;
    const startX = (playedCardsArea.offsetWidth - totalWidth) / 2;
    
    const targetPositions = [];
    for (let i = 0; i < cardsCount; i++) {
        targetPositions.push({
            x: startX + i * (cardWidth + gap),
            y: playedCardsArea.offsetHeight - 150
        });
    }
    
    // 4. 计算对手位置相对于桌面的坐标
    const opponentRect = opponentContainer.getBoundingClientRect();
    const playedCardsRect = playedCardsArea.getBoundingClientRect();
    const startX_relative = opponentRect.left - playedCardsRect.left + opponentRect.width / 2;
    const startY_relative = opponentRect.top - playedCardsRect.top + opponentRect.height / 2;
    
    // 5. 创建临时卡牌并设置起始位置
    const tempCards = [];
    for (let i = 0; i < cardsCount; i++) {
        // 创建卡牌元素
        const cardContainer = document.createElement('div');
        cardContainer.className = 'hand-card';
        cardContainer.style.position = 'absolute';
        cardContainer.style.left = `${startX_relative}px`;
        cardContainer.style.top = `${startY_relative}px`;
        cardContainer.style.zIndex = '10';
        
        // 创建卡牌画布
        const canvas = document.createElement('canvas');
        canvas.width = 70;
        canvas.height = 100;
        const ctx = canvas.getContext('2d');
        ctx.drawImage(cardImages['back'], 0, 0, canvas.width, canvas.height);
        
        cardContainer.appendChild(canvas);
        playedCardsArea.appendChild(cardContainer);
        tempCards.push(cardContainer);
    }
    
    // 6. 执行动画
    animateOpponentCards(tempCards, targetPositions, () => {
        // 动画完成后的回调
        tempCards.forEach(card => card.remove());
        
        // 在桌面显示最终的卡牌背面
        playedCardsArea.innerHTML = '';
        for (let i = 0; i < cardsCount; i++) {
            initDeckCanvas();
        }
        playedCardsArea.style.visibility = 'visible';
    });
}

// 对手卡牌动画函数
function animateOpponentCards(cards, targetPositions, callback) {
    const duration = 800;
    const startTime = performance.now();
    
    // 获取起始位置
    const startPositions = cards.map(card => ({
        x: parseFloat(card.style.left),
        y: parseFloat(card.style.top)
    }));
    
    function animate(currentTime) {
        const elapsedTime = currentTime - startTime;
        const progress = Math.min(elapsedTime / duration, 1);
        const easeProgress = easeOutCubic(progress);
        
        cards.forEach((card, index) => {
            const startPos = startPositions[index];
            const targetPos = targetPositions[index];
            
            // 计算当前位置
            const currentX = startPos.x + (targetPos.x - startPos.x) * easeProgress;
            const currentY = startPos.y + (targetPos.y - startPos.y) * easeProgress;
            
            // 更新卡牌位置
            card.style.left = `${currentX}px`;
            card.style.top = `${currentY}px`;
        });
        
        if (progress < 1) {
            requestAnimationFrame(animate);
        } else {
            callback();
        }
    }
    
    requestAnimationFrame(animate);
}

   loadImages();

</script>

</html>